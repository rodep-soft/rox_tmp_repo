# robot_localization EKF configuration for IMU fusion
ekf_filter_node:
  ros__parameters:
    # The frequency, in Hz, at which the filter will output a position estimate
    frequency: 30.0
    
    # The period, in seconds, after which we consider a sensor to have timed out
    sensor_timeout: 0.1
    
    # If this is set to true, no 3D information will be used in your state estimate
    two_d_mode: false
    
    # Use this parameter to provide an offset to the transform generated by ekf_localization_node
    transform_time_offset: 0.0
    
    # Use this parameter to provide specify how long the tf listener should wait for a transform to become available
    transform_timeout: 0.0
    
    # If you're having trouble, try setting this to true, and then echo the /diagnostics_agg topic to see
    # if the node is unhappy with any of your data
    print_diagnostics: true
    
    # Debug settings
    debug: false
    debug_out_file: /tmp/ekf_debug.txt
    
    # Defaults to "robot_localization_debug.txt" if unspecified. Please specify the full path.
    # Remove the sensor data that is subject to outliers, before running the ekf
    remove_gravitational_acceleration: true
    
    # REP-105 (http://www.ros.org/reps/rep-0105.html) specifies four principal coordinate frames: base_link, odom, map, and
    # earth. base_link is the coordinate frame that is affixed to the robot. Both odom and map are world-fixed frames.
    # The robot's position in the odom frame will drift over time, but is accurate in the short term and should be
    # continuous. The odom frame is therefore the best frame for executing motion commands. The position in the map
    # frame will drift slowly but is globally accurate and should be discontinuous. The earth frame is used to relate
    # multiple map frames by giving them a common reference frame. ekf_localization_node and ukf_localization_node are
    # not concerned with the earth frame.
    # Here is how to use the following settings:
    # 1. Set the map_frame, odom_frame, and base_link_frame parameters to the appropriate frame names for your system.
    #    1a. If your system does not have a map_frame, just remove it, and make sure "world_frame" is set to the value of odom_frame.
    # 2. If you are fusing continuous position data such as wheel encoder odometry, visual odometry, or IMU data, set "world_frame"
    #    to your odom_frame value. This is the default behavior for robot_localization's state estimation nodes.
    # 3. If you are fusing global absolute position data that is subject to discrete jumps (e.g., GPS or position updates from landmark
    #    observations) then:
    #    3a. Set your "world_frame" to your map_frame value
    #    3b. MAKE SURE something else is generating the odom->base_link transform. Note that this can even be another state estimation node
    #        from robot_localization! However, that instance should *not* fuse the global data.
    map_frame: map
    odom_frame: odom
    base_link_frame: base_link
    world_frame: odom
    
    # The filter accepts an arbitrary number of inputs from each input message type (nav_msgs/Odometry,
    # geometry_msgs/PoseWithCovarianceStamped, geometry_msgs/TwistWithCovarianceStamped,
    # sensor_msgs/Imu). To add an input, simply append the next number in the sequence to its "base" name, e.g., odom0,
    # odom1, twist0, twist1, imu0, imu1, imu2, etc. The value should be the topic name. These parameters obviously have
    # no default values, and must be specified.
    
    # IMU from BNO055 (raw data with hardware failure detection)
    imu0: /imu/data_raw
    
    # IMU from Madgwick filter (fused orientation)
    imu1: /imu/data
    
    # The next set of parameters define how much we trust the data from each sensor. The order of the values is:
    # x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az
    # 
    # For imu0 (raw BNO055 data):
    # - We don't trust position (x,y,z): false, false, false
    # - We trust orientation but with reduced confidence due to Z-axis failure: true, true, false (no yaw)
    # - We don't trust linear velocities: false, false, false  
    # - We trust angular velocities but not Z due to hardware failure: true, true, false
    # - We trust linear accelerations: true, true, true
    imu0_config: [false, false, false,
                  true,  true,  false,
                  false, false, false,
                  true,  true,  false,
                  true,  true,  true]
    
    # For imu1 (Madgwick filtered data):
    # - We don't trust position: false, false, false
    # - We trust all orientation from Madgwick: true, true, true
    # - We don't trust linear velocities: false, false, false
    # - We trust angular velocities from Madgwick: true, true, true  
    # - We don't use accelerations from filtered data: false, false, false
    imu1_config: [false, false, false,
                  true,  true,  true,
                  false, false, false,
                  true,  true,  true,
                  false, false, false]
    
    # [ADVANCED] Some IMUs automatically remove acceleration due to gravity, and others don't. If yours doesn't, please set
    # this to true, and *make sure* your data conforms to REP-103, specifically, that the data is in ENU frame.
    imu0_remove_gravitational_acceleration: true
    imu1_remove_gravitational_acceleration: true
    
    # [ADVANCED] The EKF and UKF models follow a standard predict/correct cycle. During prediction, if there is no
    # acceleration reference, the velocity at time T+1 is simply predicted to be the same as the velocity at time T.
    # During correction, this predicted value is fused with the measured value to produce the new velocity estimate. This can be
    # problematic, as the final velocity will effectively be a weighted average of the old velocity and the new one. When the
    # velocity is not changing, this is fine, but when the robot is accelerating, the old velocity should be thrown out in
    # favor of the new velocity. The alpha gain variable provides a mechanism for ensuring that new measurements are weighted
    # more heavily than old measurements. Larger values of alpha result in faster convergence. However, if alpha is too large,
    # the values will be noisy. The default alpha is 0.001. If you're getting noisy values, try decreasing it. If your sensor
    # data is accurate and you want faster convergence, try increasing it.
    alpha: 0.001
    
    # [ADVANCED] The ekf_localization_node and ukf_localization_node can save the measurement history for each sensor so that
    # measurements made earlier can still be integrated after a sensor publishes data with a timestamp that is in the past.
    # This is controlled by the <sensorName>_queue_size parameter, e.g., odom0_queue_size. The default value is 2, and setting
    # it to 0 is the same as setting it to 1. Increasing the value will cause the filter to increase the size of the measurement
    # queue for that sensor, and decrease the time between measurement integration, which will improve accuracy, but may negatively
    # impact real-time performance. An optimal value would be just large enough to account for the largest time delta between
    # messages and the frequency of your.
    imu0_queue_size: 5
    imu1_queue_size: 5
    
    # [ADVANCED] Large messages in ROS can exhibit strange behavior when they arrive at a high frequency. This frequency, in Hz,
    # specifies the maximum frequency for each sensor. NOTE: this does *not* force a sensor to publish at a specific rate. Rather,
    # if a given sensor's data is arriving at a rate greater than this value, the filter will not use it until the next iteration.
    # Users should take care *not* to set these values very low.
    imu0_throttle_frequency: 30.0
    imu1_throttle_frequency: 30.0
    
    # [ADVANCED] When measuring the pose of a robot, some sensors can have their measurements applied to different parts of the
    # robot. For example, if you have an odometry message as input, but you want to apply it to a frame that is base_link's
    # child, instead of base_link itself, you can specify the measurement's target frame. You can override the output frame for
    # each measurement. It is assumed that this frame_id is also being broadcast to tf.
    # NOTE: this is an advanced option, and should not be used unless you know what you're doing! It will require careful
    # editing of your .launch file and possibly custom tf publishers. robot_localization assumes that all input frames are
    # descendants of the tracking frame.
    imu0_pose_use_child_frame: false
    imu1_pose_use_child_frame: false
    
    # [ADVANCED] When the filter processes measurements, it checks to see if those measurements are significantly far apart
    # from where the filter expects them to be. Messages whose distance from the filter's current estimate exceed a threshold
    # are rejected by the filter. This allows the filter to ignore measurements that are clearly wrong and could corrupt the
    # filter's state. Users should take care to set this threshold to a reasonable value, but should avoid making it too small.
    # Note that if you are testing your setup stationary, and you have a 0 velocity process noise setting, many GPS messages
    # will be rejected because they will not be at (0, 0). In this case, set this threshold to a very large value. The threshold
    # is specified for each variable in order of (x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az).
    imu0_pose_rejection_threshold: 0.8
    imu1_pose_rejection_threshold: 0.8
    
    # [ADVANCED] Similar to the pose rejection threshold, users can specify a threshold for velocities. The order is
    # (vx, vy, vz, vroll, vpitch, vyaw).
    imu0_twist_rejection_threshold: 0.8
    imu1_twist_rejection_threshold: 0.8
    
    # [ADVANCED] Similar to the pose rejection threshold, users can specify a threshold for accelerations. The order is
    # (ax, ay, az).
    imu0_linear_acceleration_rejection_threshold: 0.8
    
    # [ADVANCED] If your data is subject to outliers, use these threshold settings, expressed as Mahalanobis distances, to control
    # how far away from the current vehicle state a sensor measurement is allowed to be. Each defaults to numeric_limits<double>::max()
    # if unspecified. It is strongly recommended that these parameters be removed if not required. Data is specified at the level
    # of pose and twist variables, rather than for each variable in isolation. For messages that have both pose and twist data,
    # the parameter specifies to which part of the message the threshold applies.
    imu0_differential: false
    imu1_differential: false
    
    # [ADVANCED] When robot_localization receives a measurement from a given sensor, it sets the initial estimate of the variable
    # in question to that measurement. If your IMU does not produce orientation data, then robot_localization will still use the
    # acceleration and angular velocity data from it to predict the orientation. If, however, the user want to *ignore* the
    # initial estimate, then they should set this to true.
    imu0_relative: false
    imu1_relative: false
    
    # [ADVANCED] By default, the subscription queue size for each message type is 1. If you wish to increase that so as not to
    # drop messages that arrive quickly, you can do so here.
    # Queue sizes already defined above
    
    # [ADVANCED] Users can specify an optional gravitational acceleration value here. If specified, it will be subtracted from
    # your IMU's linear acceleration data. If you don't specify this value, it will be set to the value implied by
    # your "world_frame."
    gravitational_acceleration: 9.80665
    
    # [ADVANCED] Some IMUs produce orientation data, but the TF frame_id set by the IMU driver may not be oriented appropriately
    # for your robot. This parameter allows you to apply a static transform to individual IMU measurements before fusing them.
    # The order of the values is (x, y, z, roll, pitch, yaw). NOTE: the transform is applied to the IMU data first, and then the
    # differential setting is applied.
    # imu0_config already accounts for sensor frame, but we can add transforms if needed
    # imu0_mag_config: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false]
    
    # [ADVANCED] As of version 2.3.0, users can override the default subscription queue size using this parameter. The default
    # value is 1.
    use_control: false
    
    # Most users will be able to remove the remainder of this file, as it just contains example settings. You are encouraged to
    # generate your own settings to suit your application.
    
    # Process noise covariance matrix. The values are ordered as x, y, z, roll, pitch, yaw, vx, vy, vz,
    # vroll, vpitch, vyaw, ax, ay, az. Defaults to the 3x3 identity matrix if unspecified.
    process_noise_covariance: [0.05, 0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0.05, 0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0.06, 0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0.03, 0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0.03, 0,    0,     0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0.06, 0,     0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0.025, 0,     0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0.025, 0,    0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0.04, 0,    0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0,    0.01, 0,    0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0.01, 0,    0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0.02, 0,    0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0.01, 0,    0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0.01, 0,
                               0,    0,    0,    0,    0,    0,    0,     0,     0,    0,    0,    0,    0,    0,    0.015]
    
    # Initial state covariance matrix. The values are ordered as x, y, z, roll, pitch, yaw, vx, vy, vz,
    # vroll, vpitch, vyaw, ax, ay, az. Defaults to the 3x3 identity matrix if unspecified.
    initial_estimate_covariance: [1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1e-9, 0,    0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1e-9, 0,
                                  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1e-9]
